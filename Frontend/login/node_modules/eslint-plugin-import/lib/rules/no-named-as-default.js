'use strict';var _builder = require('../exportMap/builder');var _builder2 = _interopRequireDefault(_builder);
var _importDeclaration = require('../importDeclaration');var _importDeclaration2 = _interopRequireDefault(_importDeclaration);
var _docsUrl = require('../docsUrl');var _docsUrl2 = _interopRequireDefault(_docsUrl);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}

module.exports = {
  meta: {
    type: 'problem',
    docs: {
      category: 'Helpful warnings',
      description: 'Forbid use of exported name as identifier of default export.',
      url: (0, _docsUrl2['default'])('no-named-as-default') },

    schema: [] },


  create: function () {function create(context) {
      function checkDefault(nameKey, defaultSpecifier) {
        /**
                                                         * For ImportDefaultSpecifier we're interested in the "local" name (`foo` for `import {bar as foo} ...`)
                                                         * For ExportDefaultSpecifier we're interested in the "exported" name (`foo` for `export {bar as foo} ...`)
                                                         */
        var analyzedName = defaultSpecifier[nameKey].name;

        // #566: default is a valid specifier
        if (analyzedName === 'default') {return;}

        var declaration = (0, _importDeclaration2['default'])(context, defaultSpecifier);
        /** @type {import('../exportMap').default | null} */
        var importedModule = _builder2['default'].get(declaration.source.value, context);
        if (importedModule == null) {return;}

        if (importedModule.errors.length > 0) {
          importedModule.reportErrors(context, declaration);
          return;
        }

        if (!importedModule.hasDefault) {
          // The rule is triggered for default imports/exports, so if the imported module has no default
          // this means we're dealing with incorrect source code anyway
          return;
        }

        if (!importedModule.has(analyzedName)) {
          // The name used locally for the default import was not even used in the imported module.
          return;
        }

        /**
           * FIXME: We can verify if a default and a named export are pointing to the same symbol only
           * if they are both `reexports`. In case one of the symbols is not a re-export, but defined
           * in the file, the ExportMap structure has no info about what actually is being exported --
           * the value in the `namespace` Map is an empty object.
           *
           * To solve this, it would require not relying on the ExportMap, but on some other way of
           * accessing the imported module and its exported values.
           *
           * Additionally, although `ExportMap.get` is a unified way to get info from both `reexports`
           * and `namespace` maps, it does not return valid output we need here, and I think this is
           * related to the "cycle safeguards" in the `get` function.
           */

        if (importedModule.reexports.has(analyzedName) && importedModule.reexports.has('default')) {
          var thingImportedWithNamedImport = importedModule.reexports.get(analyzedName).getImport();
          var thingImportedWithDefaultImport = importedModule.reexports.get('default').getImport();

          // Case: both imports point to the same file and they both refer to the same symbol in this file.
          if (
          thingImportedWithNamedImport.path === thingImportedWithDefaultImport.path &&
          thingImportedWithNamedImport.local === thingImportedWithDefaultImport.local)
          {
            // #1594: the imported module exports the same thing via a default export and a named export
            return;
          }
        }

        context.report(
        defaultSpecifier, 'Using exported name \'' + String(
        defaultSpecifier[nameKey].name) + '\' as identifier for default ' + (nameKey === 'local' ? 'import' : 'export') + '.');


      }

      return {
        ImportDefaultSpecifier: checkDefault.bind(null, 'local'),
        ExportDefaultSpecifier: checkDefault.bind(null, 'exported') };

    }return create;}() };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9uby1uYW1lZC1hcy1kZWZhdWx0LmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJtZXRhIiwidHlwZSIsImRvY3MiLCJjYXRlZ29yeSIsImRlc2NyaXB0aW9uIiwidXJsIiwic2NoZW1hIiwiY3JlYXRlIiwiY29udGV4dCIsImNoZWNrRGVmYXVsdCIsIm5hbWVLZXkiLCJkZWZhdWx0U3BlY2lmaWVyIiwiYW5hbHl6ZWROYW1lIiwibm